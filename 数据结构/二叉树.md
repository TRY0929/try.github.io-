# 二叉树

+ 二叉树的递归定义：二叉树或为空树，或是由一个根节点加上两颗分别称为左子树和右子树的、**互不相交**的二叉树组成。  
+ 特点：  
&emsp; 1. 每个结点最多只有两棵子树，即不存在度大于2的结点；  
&emsp; 2. 子树有左右之分，不能颠倒；  
&emsp; 此处要和**度为2的树**区分开来，度为2的树没有左右子树之分，子节点都是一样的。

-----
+ **结点的度**：结点拥有的子结点个数
+ **二叉树的深度**：结点的最大层次数（根节点是第一层，以此类推）
### 两类特殊的二叉树
+ **满二叉树**：除了最下面一层的叶子结点外，其余结点的度都是二，也就是树“满”了；
+ **完全二叉树**：和上面的满二叉树，只有最后一层的后面几个缺失  
<br />
上面两种是用顺序表存储二叉树最好的树，中间没有空间的浪费，层序遍历，从上至下，从左至右依次存储非常方便。

-----
##二叉树的特性

+ 在二叉树中，第i层上的结点数最多为2<sup>i-1</sup> (i>=1)  
+ 深度为 k 的二叉树至多有2<sup>k-1</sup>个结点. ( k ≥1)
+ 对任一棵二叉树，若叶结点数为 n<sub>0</sub>, 度为2的结点 数为 n<sub>2</sub>，则有 n<sub>0</sub>= n<sub>2</sub>+1 成立
+ 具有 n 个结点的完全二叉树，其深度 k 为： k =[log<sub>2</sub>n]+1

-----
##完全二叉树的特性
如果对一棵有 n 个结点的完全二叉树(其深度为 [log<sub>2</sub>n]+1)的结点按层次自上而下，从左至右 编号，则对任一编号为i的结点(1≤ i ≤ n )有  


1. 若 i=1, 则该结点为根结点，无双亲，若 i≠1, 则结点 i 的双亲是编号为[i/2]的结点。记为parent( i )= [i/2]  

2. 若2 i ≤ n 则结点 i 的左孩子是编号为2 i 的结点; 否则结 点i无左孩子（结点 i 为叶子结点）。

3. 若2i +1≤ n 则结点 i 的右孩子是结点2i +1;  否则结点 i 无右孩子.

-----
##满二叉树定理
+ 非空满二叉树的叶结点数等于其分支节点数加1
+ 一颗非空二叉树空子树的数目等于其结点数目加1

------
------
##二叉树的存储
+ 存什么？
+ 用哪种存储结构？
+ 怎么存？
+ 基于存储结构如何实现树和节点ADT的基本操作？

###顺序存储
+ 用一组地址连续的存储单元，以**层序顺序**存放二叉树的数据元素，结点的相对位置蕴含着结点之间的关系（对于满二叉树和完全二叉树最适用）  

父指针数组表示法
#图片*3
但顺序存储也存在缺点：

1. 只能顺序查找
2. 需预先估计大小
3. 对于不是完全二叉树的树，中间会有空间浪费，如下图
#一堆表示法的图片
#图片
<br />
###链式存储
+ 一般分为有二叉链表和三叉链表

| 二叉链表 | 三叉链表|
| ------- | --------|
| 左孩子+右孩子 | 左孩子+右孩子+父节点|
三叉链表：
#图片

-----
##二叉树的遍历——递归设计
###递归回顾
**递归设计由哪几个基本部分组成呢**

**分治法所能解决的问题一般具有以下几个特征：**

+ 该问题的规模缩小到一定的程度就可以容易地解决；
+ 该问题可以分解为若干个规模较小的相同问题，即该问题具
有最优子结构性质
+ 利用该问题分解出的子问题的解可以合并为该问题的解；
+ 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

**那么如何让来求解呢**

+ 怎样按类型的更小的问题来定义问题（分）
+ 各个递归调用怎么减小问题规模
+ 哪个问题实例可用作基例
+ 随着问题规模的减小，最终能否到达基例

-----
###遍历一般分四种
+ 先序（根 左 右）
+ 中序（左 根 右）
+ 后续（左 右 根）
+ 层次（从上到下 从左到右）

构建一颗二叉树需知道中序序列和其他任意一遍历结果  
#先+中 构建二叉树图片

<br />
&emsp; 看几个典型的分治法来写的遍历的应用：

+ 二叉树中叶节点的统计:  
&emsp;基本思想，统计左右子树的叶节点之和，不断往下，缩小的了问题规模。

#图片
```  

int countLeaf (BiTree *T)
{
    if(T==NULL) return 0;  
    if (T->lchild==NULL && T->rchild==NULL) return 1;  
    return countLeaf(T->lchild)+countLeaf(T->rchild);  
}

```

+ 求二叉树的深度：
&emsp;基本思想，求出左右子树的深度，取其中较大值加1为当前深度。

```  

int depth(Bitree *T)  
{  
    if(T==NULL) return 0;  
    return 1+max(depth(T->lchild,T->rchild));  
}

```

**遍历算法不仅有这些作用，同时也能创建一颗二叉树**